---
title: C语言指针学习笔记
date: 2020-11-12 20:36:11
tags: Programming Language
---

## 指针简介

 

从根本上看，指针是一个值为内存地址的变量，正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。

## 相关概念

**赋值**

可以把地址赋给指针，例如数组名、带地址运算符&的变量名、另一个指针。

**地址运算符&**

又称取指，当其后面跟一个变量名时，& 给出该变量的地址。另外和所有变量一样，指针变量也有自己的地址和值，对于指针而言，&运算符给出指针本身的地址。

**地址运算符\***

又称为解引用，当其后面跟一个指针名或地址时，*给出储存再指针指向地址上的值。

**指针与整数相加**

当使用+运算把指针与整数相加时，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。

**递增指针**

让指向数组元素的指针移动至数组的下一个元素。

**指针减去一个整数**

格式必须为“指针-整数”，该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。

**递减指针**

让数组元素的指针移动至数组的上一个元素。

**指针求差**

可以计算两个指针的差值，即两个元素之间的距离，差值的单位与数组类型的单位相同。

## 指针的声明

声明指针变量时，必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小，并且程序必须知道储存在指定地址上的数据类型。指针的声明如下：

```c
int * pi;             // pi是指向int类型变量的指针
char * pc;            // pc是指向char类型变量的指针
float * pf, * pg;     // pf、pg都是指向float类型变量的指针
```

## 使用指针在函数之间通信

代码示例如下，注意函数调用interchange(&x, &y);传递的不是x和y的值，而是它们的地址。

```c
// swap3.c
#include <stdio.h>

int main(void){
    int x = 5, y = 10;
    printf("Orginally x = %d and y = %d.\n", x, y);
    
    interchange(&x, &y);     // 把地址发送给函数
    printf("Now x = %d and y = %d.\n", x, y);
    
    return 0;
}

void interchange(int * u, int * v){
    int temp;
    temp = *u;              // temp获得u所指向对象的值
    *u = *v;
    *v = temp;
}
```

## 指针和数组

在某种程度上，数组表示法其实是在变相地使用指针。指针的值是它所指向对象的地址，大部分计算机按字节编址。在指针前面使用*运算符可以得到该指针所指向对象的值。指针加1，则指针的值递增它所指向类型的大小。

下面第一行代码处，两者都表示数组首元素的内存地址，且三行代码的值都是True。

```c
flizny == &flizny[0];      // 数组名是该数组首元素的地址
dates + 2 == &date[2];     // 相同的地址
*(dates + 2) == dates[2];  // 相同的值
```

由于\*运算符的优先级高于+，所以\*dates+2相当于(*date)+2，即第一个元素的值+2

```c
*(dates +2)     // dates第三个元素的值
*date + 2       // dates第一个元素的值加2
```

## 函数、数组和指针c

函数原型和调用

```c
int sum(int * ar);      // 对应的函数原型
total = sum(marbles);   // 可能的函数调用
```

一些等价的函数原型

```c
int sum(int *ar, int n);
int sum(int *, int);
int sum(int ar[], int n);
int sum(int [], int);
```

函数定义中不能省略参数名

```c
int sum(int * ar, int n){}
int sum(int ar[], int n){}     // 两者是等价的
```

指针形参

```c
int sump(int * start, int * end);
answer = sump(marbles, marbles + SIZE);
```

 一元运算符\*和++的优先级相同，单是结合律是从右往左，所以start++先求值，然后才是\*start，若要从左往右，则需改成(*start)++，下面的语句是等价的。

```cc
total += *start;     //把数组元素的值加起来
start++;             // 让指针指向下一个元素
// 上面的两行语句等价于下面的语句
total += *start++;
```

指针操作

```c
ptr1 = urn;        // 把一个地址赋给指针
ptr2 = &urn[2];    // 把一个地址赋给指针的另外一种形式
ptr1++;            // 递增指针
ptr2--;            // 递减指针
```

**不要解引用未初始化的指针**

下面的第二行想把5储存在pt指向的位置，但是pt未被初始化，其值是一个随机值，因此程序不知道将5储存在何处。

```c
int * pt;          // 未初始化的指针
*pt = 5;           // 严重的错误
double * pd;       // 未初始化的指针
*pd = 2.4;         // 严重的错误
```

指针和多维数组

```c
int (* pz)[2];     // pz指向一个内含两个int类型值的数组
int * pax[2];      // pax是一个内含两个指针元素的数组，每个元素都指向int的指针
```

指针的兼容性

```c
int n = 5;
double x;
int * pl = &n;
double * pd = &x;
x = n;               // 隐式类型转换
pd = pl;             // 编译时错误

int * pt;
int (*pa)[3];
int ar1[2][3];
int ar2[3][2];
int **p2;            // 一个指向指针的指针

pt = &ar1[0][0];     // 都是指向int的指针
pt = ar1[0];         // 都是指向int的指针
pt = ar1;            // 无效
pa = ar1;            // 都是指向内含3个int类型元素数组的指针
pa = ar2;            // 无效
p2 = &pt;            // both pointer-to-int *
*p2 = ar2[0];        // 都是指向int的指针
p2 = ar2；           // 无效
```